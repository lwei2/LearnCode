C++笔记
=========

# 目录
> * [1.C++简介] (#chapter-1)
> * [2.C++基础知识] (#chapter-2)
> * [3.C++类与对象] (#chapter-3)
> * [4.C++之函数] (#chapter-4)


# 1. <a id="chapter-1"></a>C++简介
	1.早期的程序设计被称为结构化程序设计，也叫面向过程的程序设计。
	
	2.所谓面向对象的程序设计指的是以对象为编程核心的程序设计思想。
	
	3.类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述。
	
	4.类是对象的抽象，对象是类的实例化。
	
	5.在C++中，我们必须利用类来创建对象，而类可以自己定义和使用系统提供的或他人编写的。
	
	6.C++完全支持面向对象的程序设计,具有封装,抽象,继承,多态特征。
	
	7.面向对象和面向过程程序设计的特点:
		1)面向过程的开发效率低，可重用性差；
		2)程序的维护成本高，无法适应信息快速膨胀和多样化；
		3)面向对象的优势在于开发效率高，可重用性高，容易维护。
	
	8.C++语言的主要特点:
		1)C++是对C的增强和扩展;
		2)C++保留了C语言的全部特征,并支持所有面向对象的程序设计特征;
		3)C++保持C的简洁，高效，灵活和接近汇编语言特点。
	
	9.C++程序开发过程:编写源程序(.cpp),编译程序,连接目标文件,运行程序。
		1）编写源程序:C++作为一种高级语言，以.cpp为后缀名
		2）编译程序:计算机不能识别高级语言，为将源程序翻译成为计算机可以识别的二进制指令，需将源程序进行编译，而编译后生成的文件称为目标文件，以.obj作为后缀名。
		3）连接目标文件:一个工程可能会包含很多个C++源程序，编译后会生成很多独立的目标文件，执行连接操作时，会将目标文件和库文件以及系统提供的其他信息连接起来，形成可执行文件。
		4）运行可执行文件，即可得到运行结果。

# 2.<a id="chapter-2"></a>C++的基本知识

## 2.1 C++程序的基本构成

	一个C++程序由一个或多个源程序构成，每个源程序均可称一个文件。

	在源程序中，一般由预处理命令，全局声明部分，函数等。
	
	C++提供了三种预处理命令：宏定义命令，文件包含命令和条件编译命令。

	程序中所有的C++预处理命令均以“#”开头，且末尾不加分号。

	用#define命令指定一个标识符来代表一个字符串称为宏定义，其一般形式如下：
```
			#define 标识符  字符串
			#define 宏名(参数表) 字符串
```
	在进行预处理时，程序中出现的所有宏名都用宏定义中的字符串代替，但并不会为其分配内存，从而提高程序的通用性和可读性。

	一个源程序将另一个源程序的全部内容包含进来称为文件包含。

	在C++中，用#include命令实现文件包含，其一般形式：#include<文件名> 或者#include"文件名"
	文件包含命令若使用尖括号表示在系统指定的目录中查询要包含的文件。若使用双引号表示在源文件目录下查找要包含的文件。

	C++程序中经常使用系统的库函数，在调用一个库函数时，必须将该库函数所在的文件包含进来，这种被包含的文件夹称为头文件。

	头文件一般包含对类型的声明、函数声明、内置函数的定义、宏定义、全局变量定义和外部变量声明等。

	一般情况下，在进行编译时对源程序中的每一行都要编译，但有时需要按不同的条件去编译不同的程序部分，称为条件编译。

	C++中的条件编译有如下三种形式：
```
	#ifdef 标识符
		程序段1
	#else
		程序段2
	#endif
```
```
	#ifndef 标识符
		程序段1
	#else 
		程序段2
	#endif
```
```
	#if 表达式
		程序段1
	#else
		程序段2
	#endif

```

## 2.2 C++的数据类型
	
	在数学中，将整数和分数称为有理数，将无限不循环小数和开根开不尽的数称为无理数，而有理数和无理数称为实数。
	
	C++的数据类型主要包括基本类型和构造类型。
	
	不同的数据类型，其区别主要为 1）所要表示的对象不同。2）声明的方式不同。3）所占存储空间不同。
	
	C++的基本数据类型有整型、字符型、单精度浮点型、双精度浮点型、空类型。其中，signed,unsigned,short,long被称为修饰词。
	
	正数的原码、补码、反码均相同。

	负数的原码是该负数绝对值的二进制取反加1；反码等于原码最高位不变，其余取反；补码等于原码最高位不变，取反加1。

	有符号整数在计算机内以二进制补码的形式存储的，存储单元的最高位用来表示数值的符号，“0”表示“正”，“1”表示“负”。
	
	无符号整数只能是0和正数，其全部二进制位均表示数值本身。
	
	字符型本质上是整型，用于存放字符的ASCII码，长度为1个字节。
	
	布尔类型，简称为逻辑型，数据的取值只能是true(真)或false(假)。
	
	空类型，常常作用于对函数返回值和函数参数的限定和定义无类型通用指针。
	
	每种数据类型均会占据固定长度的字节，这决定了它所能代表的数值范围。
	任何一种数据类型都有一个确定的最大值和最小值，若该类型数值的变化超出了这个范围，即比最大值还大，比最小值还小，则会不正确，此种现象称为溢出。
	
	在C++中，当表达式中出现多种不同类型数据的混合运算时，往往需要进行数据类型转换。
	
	数据类型的转换分为隐含转换和强制转换。
	数据类型的隐含转换是指当运算符两边数据的类型不同时，系统自动会将其转换成同一数据类型后再进行运算。转换规则是将低类型数据转换为高类型数据,即char,short->int->unsigned->long->double  |	float->double

	强制转换数据类型的一般形式为：(类型名) 变量/表达式 或者 类型名(变量/表达式)
	强制类型转换是暂时的，一次性的，只是将所需要转换的值从原变量中取出，转换类型后放在一个所需类型的中间变量中，而原来的变量类型不发生改变。
	
	强制类型转换是一种不安全的转换，会引起数据丢失。

## 2.3 常量和变量
	常量是指在程序执行过程中值保持不变的量。

	变量是指在程序运行过程中可以改变的量。
	
	每个变量都必须在声明时明确定义其数据类型，并用标识符标识。

	常量分为字面常量和符号常量。

	符号常量是一个标识符，对应着一个和它类型一致的存储空间，该存储空间保存的数据即为该符号常量的值。

	C++中的常量分为整型常量、实型常量、字符常量、字符串常量和布尔型常量。

	整型常量表示通常意义上的整数，可以用十进制、八进制、十六进制表示。
		1)十进制整型常量：由正、负号和数字0-9组成，但数字部分不能以0开头。
		2)八进制整型常量：由正、负号和数字0-7组成，数字部分以0开头。
		3)十六进制整型常量：由正、负号和数字0-9，字母A-F组成，数字部分以0x或0X开头。

	实型常量是指通常意义上的实数，有两种表示形式：十进制小数形式和指数形式。
		1)十进制小数形式:由数字0-9和小数点组成。
		2)指数形式：也称科学计数法，其格式为小数E或e指数，表示“小数X10指数”。其中，小数可为正负，指数可为正负。
	
	字符常量分为普通字符常量和转义字符常量。

	普通字符常量是用单引号括起来的一个字符，且它只能包括一个字符，区分大小写。

	转义字符常量是由"\"开头的一个或多个字符的序列，用于表示一些无法显示的字符。

	字符串常量是由一对双引号括起来的零个或多个字符序列。
	字符串常量与字符常量有所不同，字符型常量在内存中只占一个字节，字符串是按照串中字符的排列顺序存放的，每个字符占一个字节，并在尾部添加"\0"作为字符串结尾标志或结束标志。

	布尔型常量只有两个值，即整数0（表示逻辑假）和1（表示逻辑真）。

	若程序中需要多次使用某个常量，即定义为符号，从而提高程序的可读性，并便于修改。

	声明符号常量的形式为：const 数据类型 常量名 = 数值/表达式。

	符号常量在声明时必须赋初值，且在程序中间不能改变其值。通常情况下符号常量的名称一般用大写符号表示。
	在计算机中，内存是由一个个存储单元组成的，每个存储单元都有一个编号，即存储单元的地址。通过地址找到每个存储单元以读取或写入相应的数据。
	为了读写数据的方便，编程语言中引入了变量。编译器在编译程序时会为每个变量分配相应的内存。因此，程序可以通过变量名来访问相应的内存。

	变量名即变量标识符，由字符、数字和下划线组成，且第一个字符必须是字母或下滑线。变量名不允许使用C++关键字、系统函数名和系统类名。

	变量命名的一些规则：1.标识符采用英文单词或其组合，保证直观且用词准确，可望文知意；
						2.遵循最小化长度与最大化信息量原则。在保证一个标识符意思明确的同时，应当尽量缩短其长度。
						3.避免标识符过于相似。
						4.用正确的反义词组命名具有相斥意义的标识符。
						4.除非逻辑上的确需要编号，否则尽量避免名字中出现数字编号。
						5.保持在整个模块中命名风格的统一性。
	
	变量的定义用于为变量分配存储空间，以存放变量值。其中变量的存储空间大小由变量的类型决定。

	变量定义的一般形式：数据类型  变量名,....;

	变量的声明用于向程序表明变量的类型和名字，它并不一定为变量分配内存单元。由于在定义变量时声明了它的类型和名字，因此变量定义可看做变量声明的一种，即定义性声明。

## 2.4 C++的运算符，表达式和优先级
	不同的运算符所需要指定的操作数个数不同，依据此将运算符分为单目运算符，双目运算符和三目运算符。

	表达式由操作对象，运算符和括号组成。根据运算规则执行表达式，所得结果称为表达式的值。

	C++规定了运算符的优先级和结合性。在求解表达式时，先进行优先级高的运算，再进行优先级低的运算。若一个操作数两边运算符的优先级相同，则按运算符的结合性进行运算。

	用运算符和括号将操作数连接起来，符合C++语法规定的式子叫做算术表达式。

	带有赋值运算符的表达式称为赋值表达式。赋值表达式的作用是将赋值号右侧表达式赋给左侧变量的类型。

	赋值表达式的一般形式为：变量名 = 数值/表达式。

	赋值表达式的结合方向是自右向左。

	C++提供了用于比较、判断的关系运算符，其中算术运算符优先级高于关系运算符，关系运算符优先级高于赋值运算符。

	用关系运算符将两个表达式连接起来，称为关系表达式。关系表达式的一般形式为：表达式 关系运算符 表达式

	关系表达式的结合方向是自左向右。

	用逻辑运算符将不同类型的表达式连接起来，符合C++语法规则的式子称为逻辑表达式。逻辑表达式的值只能是1或0。

	条件运算符包括三个操作表达式，是C++中唯一的三目运算符。

	条件表达式的一般形式为：表达式1？表达式2：表达式3

	用逗号运算符将两个或两个以上的表达式连接起来的式子称为逗号表达式。

	逗号表达式的一般形式为：表达式1,表达式2,...,表达式n

	逗号运算符即顺序求值运算符，它表示系统会自动按顺序执行由逗号运算符分隔的各表达式，并且逗号表达式的值是最右边的子表达式的值。

	逗号运算符的优先级是所有运算符中级别最低的，其结合方向为从左至右。

	移位运算符分为左移运算符和右移运算符。

	右移运算符表示按照指定的位数将一个数的二进制值向右移位，低位右移后溢出舍弃。若是无符号整数，高位顺序补0；若是有符号整数，原符号位为0，则高位顺序补0，原符号位为1，则高位顺序补1。右移一位相当于该数除以2，右移n位相当于处于2的n次放。

	左移运算符表示按照指定的位数将一个二进制值向左移位，高位左移后溢出舍弃，低位顺序补0。左移一位相当于该数乘以2，左移n位相当于乘以2的n次方。

## 2.5 C++语句类型
	一个源程序一般由预处理命令、全局声明部分和函数构成。

	语句是C++程序最基本的单位，它有多种形式，以分号作为结束标志。

	C++语句分为声明语句、执行语句、空语句和复合语句。

	C++声明语句主要用于变量、常量、函数、类型等的声明和定义。

	在C++程序中，一个名称在使用之前必须先对其进行声明，其目的是告诉编译器该名称所指代的实体类型。
	全局声明变量主要用于堆全局变量的声明和定义、函数的声明、类的声明和定义等，作用范围是从声明语句开始到本源程序单元结束。

	局部声明语句用于对局部变量的定义，作用范围是从声明语句开始到本函数或本程序块结束。

	执行语句的主要功能是实现具体操作，包括表达式语句、基本输入输出语句和控制语句。

	由一个表达式加上一个分号构成的语句称为表达式语句。

	C++程序的输入输出操作通过标准库中的输入流和输出流语句完成。

	控制语句用于实现程序的控制结构，C++的控制语句分为选择语句，循环语句和转向语句。

	只有一个分号组成的语句称为空语句。它不执行任何操作，在程序中，空语句通常用来作循环语句中的循环体，起延时的作用。

	将若干条语句用{}括起来称为复合语句，又称为块语句。

	复合语句在程序中通常作为函数的函数体、循环语句的循环体、if语句的分支等。

	C++程序的控制结构包括顺序结构、选择结构和循环结构。

	顺序结构是指按照所有语句出现的先后顺序来执行程序。

	选择结构是指判断给定的条件是否满足要求，并根据判断结果选择执行不同的分支结构。
```	
	if(表达式)
		语句;
	else if(表达式)
		语句;
	else
		语句;

	switch(表达式)
	{
		case 常量表达式1:
			语句1;
			break;
			
			...

		case 常量表达式n:
			语句n;
			break;
		default:
			语句n+1;
			break;
	}

```
	C++中常用的循环语句主要有三种，即for循环语句、while循环语句、do-while循环语句。
	for循环语句的一般形式为:
```	
	for(表达式1;表达式2;表达式3;)
		循环体语句;

```
	for循环语句中表达式１是对循环变量进行初始化，表达式２是循环条件，表达式３是循环变量的增量，重复执行的语句为循环体.
	
	while语句的一般形式为:
```
	while(表达式)
	{
		循环体语句;
	}

```
	while语句先判断表达式的值，若为真，则执行循环体，否则，终止循环体。循环体内进行循环控制变量的修改。与while语句相比，do~while语句先执行一次循环体语句，然后判断是否满足循环条件，do~while语句中的循环体至少被执行一次。
	do~while语句的一般形式:
```
	do{

	}while(表达式);

```
	在一个循环的循环体中又包含另一个循环语句称为循环嵌套，又称多重循环。三种循环可以相互嵌套，执行顺序是先执行最里层的循环语句，依次往外执行，最后执行最外层的循环。但要注意，内层循环必须包含在外层循环中，不能交叉。

	转向语句是用于控制程序执行顺序，实现程序无条件转移的语句，常用的转向语句有break,continue,goto,return。

	break语句又称跳出语句，其一般形式为: break;
	break语句常用于循环语句中时，可使程序结束循环，继续执行循环后面的语句；也常用于switch语句中时，可使程序跳出switch语句，继续执行switch后面的语句。

	continue语句又称为继续语句，其一般形式为: continue;

	continue语句用于循环语句中，可使程序结束本次循环，即跳过循环体中的continue后面的语句，转去判断循环控制条件，决定是否进行下一次循环。

	continue语句和break语句的区别是continue语句只结束本次循环，不结束整个循环结构，而break语句则是结束整个循环结构。

	goto语句为无条件转移语句，一般形式为: goto 语句标号;其中，语句标号是一个标识符，放在某一语句行的前面，标号后面加冒号”:“。该语句的功能是使程序无条件跳转到标号所指的语句处执行。

	使用goto语句会影响程序的结构，因此，在结构化程序设计中尽量不要使用goto语句。

	return语句又称为返回语句，其一般形式为:return 表达式;

	return语句的功能是停止执行当前函数，指定函数要返回的值，转去执行调用该函数后面的语句。

## C++内存对齐
	类中非静态成员变量的大小于编译器内存对齐：

	1.第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。
	
	2.在数据成员完成各自对齐后，类（结构或联合体）本身也要进行对齐，对齐按照#pragma pack指定的数值和结构或联合体最大数据成员长度中，比较小的那个进行。


## C++的引用
1.1 在声明引用时，必须同时对其进行初始化。引用的声明一般形式： 类型标识符 &引用名 = 被引用对象;

1.2 若不希望通过引用来改变原始变量的值，即称为常引用。常引用的声明一般形势：const 类型标识符 &引用名 = 被引用对象

1.3 在声明或定义函数时，将函数的形参执行为引用，则在调用该函数时会将实参直接传递给形参，而不是将实参拷贝传递给形参。

## C++强制转换类型
1.1 在C++中static_cast，const_cast，reinterpret_cast，dynmic_cast均是用于强制类型转换。
```	
	static_cast<new_type>      (expression)
	dynamic_cast<new_type>     (expression) 
	const_cast<new_type>       (expression) 
	reinterpret_cast<new_type> (expression)

```
1.2 static_cast用于数据类型的强制转换，强制将一种数据类型转换称为另一种数据类型。
		a.用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
		b.进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
		c.进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
		d.用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
		e.把空指针转换成目标类型的空指针。
		f.把任何类型的表达式转换成void类型。
		注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

1.3 const_cast用于强制去掉不能修改的常数特性。 

1.4 reinterpret_cast用于改变指针或引用的类型，将指针或引用转换为一个足够长度的整型，将整型转换为指针或引用类型。

1.5 dynamic_cast用于类的继承层次之间的强制类型转换。 


## C++智能指针
1.智能指针的原理:接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也将被释放掉了（除非将智能指针保存起来）。

2.C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头文件<memory>

3.shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。shared_ptr内部的引用计数是安全的，但是对象的读取需要加锁。

4.shared_ptr初始化:通過构造函数,std::make_shared<T>辅助函数和reset方法来初始化shared_ptr。其中，reset方法
	reset()包含两个操作。当智能指针中有值的时候，调用reset()会使引用计数减1.当调用reset（new xxx()重新赋值时，智能指针首先是生成新对象，然后将就对象的引用计数减1（当然，如果发现引用计数为0时，则析构旧对象），然后将新对象的指针交给智能指针保管。

5.获取原始指针，使用get方法。

6.智能指针可以指定删除器，当智能指针的引用计数为0时，自动调用指定的删除器来释放内存。std::shared_ptr可以指定删除器的一个原因是其默认删除器不支持数组对象。

7.使用shared_ptr需要注意的问题:a.不要用一个原始指针初始化多个shared_ptr，原因在于，会造成二次销毁.b.不要在函数实参中创建shared_ptr。因为C++的函数参数的计算顺序在不同的编译器下是不同的。正确的做法是先创建好，然后再传入.
	c.禁止通过shared_from_this()返回this指针，这样做可能也会造成二次析构.d.避免循环引用。智能指针最大的一个陷阱是循环引用，循环引用会导致内存泄漏。解决方法是相应的类型改为weak_ptr.

# 3.<a id="chapter-3"></a>C++类与对象
1.


## C++多态性
1.对象的静态类型：对象在声明时采用的类型。是在编译期确定的。

2.对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。

3.静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。

4.动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。

## C++异常处理
1.在C++中，一个函数能够检测出异常并且将异常返回，称该机制为抛出异常。当抛出异常后，函数调用者捕获到该异常，并对该异常进行处理，称之为异常捕获。

2.异常处理的一般声明形式：
```
try{

}catch(异常类型n){

}
```

## C++内存区域分配理解
	1.代码段-text（code segment/text segment)
	代码段在内存中被映射为只读，但.data和.bss是可写。
	
	2.数据段-data
	数据段包含静态初始化的数据，所以有初值的全局变量和static变量在data区。段的起始位置即由连接定位文件所确定，大小在编译链接时自动分配。它和你的程序没有多少关系，但和程序使用的全局变量，常量数量有关。

	3.bss段-bss(Block Started by Symbol)
	bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域。	
	在程序
	4.stack
	栈保存函数局部变量（但不包括static变量，static意味着在数据段中存放的变量），参数以及返回值，是一种后进先出的数据结构。栈的地址空间是向下减少，当栈上岙村的数据越多，栈的地址就月底，栈的顶部在可读写的RAM去的最后。


	5.heap
	堆(heap)保存函数内部动态分配内存，是另外一种用来保存程序信息的数据结构，即保存程序的动态变量。
	堆是先进先出的数据结构，它只允许在堆的一端插入数据，在另一端删除数据。
	堆的地址空間是向上增加，即当堆上保存的数据越多，堆的地址越高。



C++虚函数的主要作用：运行时多态，父类中提供虚函数的实现，为子类提供默认的函数实现。
C++中包含纯虚函数的类，称为抽象类。抽象类不能使用new对象




# 4.<a id="chapter-4"></a>C++之函数

## 4.1 函数声明与定义
	在结构化程序设计中，为了便于组织，编写和调试程序，通常要将一个大的程序划分成若干个模块，每个模块完成特定的功能，各模块之间互相独立，这种设计思想称为模块化程序设计。

	函数是实现模块化程序设计的重要工具。

	在C++程序中，每一项操作基本上都是由一个函数来实现的。

	一个C++程序可以由若干各函数构成，但其中只能一个主函数main()。

	C++程序总是从主函数开始执行，它由系统调用，程序运行过程中主函数调用其他函数，其他函数之间也可以互相调用。

	在C++面向对象的程序设计中，主函数除外的其他函数大多数被封装在类中，主函数或其他函数可通过类对象调用类中的函数。

	函数定义的一般形式：函数类型  函数名(参数列表){函数体;}
	函数的定义中，函数的类型即函数的返回值类型。函数的返回值一般由return语句给出。若函数无返回值，则函数类型为void。函数名通常用一个能反映函数功能的单词表示，它必须要符合C++标识符命名规则，由字母、数字和下划线组成。函数名后面必须跟一对花括号，用来与其他标志符区分开。而函数体是实现函数功能的主题部分，一般是一条复合语句，用花括号括起来，中间可以是一条或若干条语句。

	C++中不允许函数嵌套定义，即不能在一个函数体中再定义另外一个函数，函数定义之间是相互独立的。
											  函数的参数列表由0个或多个参数组成，写在函数名后面的圆括号内，用于向函数传送数值或从函数带回数值。参数列表内给出的每一个参数都要指出其类型和参数名。
	
	根据参数列表中给出的参数的个数，函数可分为无参函数和有参函数。当参数个数多于1个时，参数之间用逗号隔开。

	在C++中，当在一个函数中调用另一个函数时，调用其他函数的函数称为主调函数，被其他函数调用的函数称为被调函数。

	若被调函数在使用时尚未定义，即调用在前，定义在后，则必须在函数调用前对被调函数原型进行声明。

	函数原型的声明形式：函数类型 函数名(参数列表);

	函数原型的声明语句在于让编辑器知道该函数的有关信息，便于利用这些信息去检查函数调用的合法性，保证参数的正确传递。

## 4.2 函数的参数与返回值

	定义函数时，函数名后面括号的变量名称为形式参数（简称形参）。在调用函数时，函数名括号中的参数或表达式称为实际参数（简称实参）。

	形参与实参用于实现主调函数与被调函数之间数据的传递。

	形参并不是实际存在的数据，因此在函数被调用前不占内存中的存储单元。

	在函数调用时，编译系统临时给形参分配存储单元，以便接受从实参传递来的数据。在调用结束后，形参所占的存储单元被释放.

	实参必须与形参个数相同、类型一致，且对应顺序一致。

	函数调用过程中的数据传递是由实参向形参进行的。在函数调用时，首先要计算出实参表达式值，然后给对应的形参变量分配存储单元，并将实参的值复制到形参的存储单元中，即对形参进行初始化后执行该函数。这种传递方式称为值传递。

	值传递的特点是在函数执行过程中形参的变化不会影响实参的值，即使形参的值在函数中发生了变化，实参的值也不会改变，仍为调用前的值。

	通常情况下，在调用函数时要为函数的每个形参赋予一个相应的实参值。但有时在主调函数中没有给出实参，或者多次调用同一函数使用同样的实参时，给形参设置一个默认值，被调函数即可按指定的默认值来执行。

	若函数中有多个形参，可以为每个形参指定一个默认值，也可以只对部分形参指定默认值，指定默认值必须按照从右到左的顺序进行。即为某个参数指定默认值时，其后的参数都必须指定默认值，否则已设默认值将被忽略。

	为函数中的形参设置默认值后，实参的个数可以与形参个数不同。在进行函数调用时，实参与形参按照从左到右边的顺序进行匹配，没有给出实参的，该形参就取指定的默认值。

	通过函数的调用使主调函数得到一个确定的函数值，即函数的返回值。而函数的返回值是通过return语句给出的。

	在定义函数时指定函数类型，通常，return语句中表达式的类型应与函数类型相一致。若二者不一致，则应以函数类型为准，自动进行类型转换，即函数类型决定返回值类型。

## 4.3函数的调用
	
	在堆函数原型进行声明后，即可以在其他函数中对其进行调用，整个调用过程分三步:参数传递、函数体执行和返回主调函数。

	函数调用的一般形式为:函数名(实参列表);

	若函数没有返回值，即将函数调用单独作为一个语句使用，用于完成一定的操作。

	若函数有返回值，将函数调用作为语句的一部分，利用返回值参与表达式的运算或执行某种操作。

	C++中有两种不同的函数:库函数和自定义函数。

	若使用库函数，一般应在文件头用#include命令将库函数对应的原型声明头文件包含到本文件中。

	若使用用于自定义的函数，且该函数定义与主调函数应在同一个源程序单元中，当函数定义位于主调函数之后时，则必须在调用此函数之前对被调用函数作声明。

	C++中不允许函数的嵌套定义，但允许函数的嵌套调用，即在调用一个函数时的过程中调用另一个函数。

	一个函数直接或间接地调用该函数本身，称为函数的递归调用。

	递归调用分为两种：直接递归调用和间接递归调用。

	直接递归函数是指在一个函数中直接调用自身。

	间接递归调用是指在一个函数中调用其他函数，而其他函数中又调用本函数。

递归调用的过程分为两个阶段：递推和回归。首先从原问题出发，按递归公式递推，最终达到递归终止条件，从而将一个复杂问题分解为一个相对简单且可直接求解的子问题，这个过程称为递推阶段；然后将这个问题结果逐层带入递归公式求值，最终求得原问题的解，这个过程称为回归阶段。

	使用函数可以实现代买重用，提高开发效率，但调用函数过程中程序流程的转移也降低程序的执行效率。因为在调用函数时，需要保护现场，然后转去执行被调用函数的代码，在函数调用之后，又要根据先前保存的信息回复现场，再继续执行，进而增加时间和空间的开销。

	C++允许在编译时将调用的代码直接嵌入到主调函数中，这种嵌入到主调函数中的函数称为内联函数或内置函数。

	内联函数的定义格式为：inline 函数类型 函数名(参数列表){函数体};

内联函数能有效避免函数调用的开销，程序执行效率更高。缺点：若被声明为内联函数的函数体非常大，则编译器编译后程序的可执行代码会变得很大。内联函数内不能包括循环语句和switch语句。

## 4.4 函数重载

	所谓函数重载是指同一个函数名可以对应着多个不同的函数实现。每一类实现对应着的一个函数体，这些函数名字相同，功能相同，知识参数的类型或参数的个数不同。

	在调用重载函数时，系统会根据参数的类型或个数找到与之匹配的函数并调用该函数。

## 4.5 内部函数和外部函数

	按照存储类别的不同，函数分为内部函数和外部函数。

	若只能被本文件中其他函数调用的函数称为内部函数，也称为静态函数。

	定义内部函数时，需要在函数类型的前面加关键字static。

	若一个函数既能被本文件调用也能被其他文件调用，则表示此函数是外部函数。

	定义外部函数时，在函数类型的前面加关键字extern（可以省略,省略时则默认为外部函数）。

	当在其他文件中调用外部函数时，在需要调用此函数的文件中，用extern声明所调用的函数是外部函数。















