C++笔记
=========

# 目录
> * [1.C++简介] (#main-chapter-1)
> * [2.C++基础知识] (#main-chapter-2)
> * [3.C++类与对象] (#main-chapter-3)

# 1. C++简介 <a id="main-chapter-1"></a>

	1.早期的程序设计被称为结构化程序设计，也叫面向过程的程序设计。
	2.所谓面向对象的程序设计指的是以对象为编程核心的程序设计思想。
	3.类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述。
	4.类是对象的抽象，对象是类的实例化。
	5.在C++中，我们必须利用类来创建对象，而类可以自己定义，也可以使用系统提供的或他人编写的。
	6.C++ 完全支持面向对象的程序设计:封装,抽象,继承,多态。
	7.面向对象和面向过程程序设计的特点:
		1)面向过程的开发效率地下，可重用性差；
		2)程序的维护成本高，无法适应信息快速膨胀和多样化；
		3)面向对象的优势在于开发效率高，可重用性高，容易维护。
	8.C++语言的主要特点:
		1)C++是对C的增强和扩展;
		2)C++保留了C语言的全部特征,并支持所有面向对象的程序设计特征;
		3)C++保持C的简洁，高效，灵活和接近汇编语言特点
	9.C++程序开发过程:编写源程序(.cpp),编译程序,连接目标文件,运行程序。
		1）编写源程序:C++作为一种高级语言，以.cpp为后缀名
		2）编译程序:计算机不能识别高级语言，为将源程序翻译成为计算机可以识别的二进制指令，需将源程序进行编译，而编译后生成的文件称为目标文件，以.obj作为后缀名。
		3）连接目标文件:一个工程可能会包含很多个C++源程序，编译后会生成很多独立的目标文件，执行连接操作时，会将目标文件和库文件以及系统提供的其他信息连接起来，形成可执行文件。
		4）运行可执行文件，即可得到运行结果。
# 2. C++的基本知识<a id="main-chapter-2"></a>

2.1 C++程序的基本构成
==========
	一个C++程序由一个或多个源程序构成，每个源程序均可堪称一个文件。
	在源程序中，一般由预处理命令，全局声明部分，函数等。
	C++提供了三种预处理命令：宏定义命令，文件包含命令和条件编译命令。


2.2 C++的数据类型
==========
	在数学中，将整数和分数称为有理数，将无限不循环小鼠和开根开不尽的数成为无理数，而有理数和无理数称为实数。
	C++的数据类型主要包括基本类型和构造类型。
	不同的数据类型，其区别主要为 1）所要表示的对象不同。2）声明的方式不同。3）所占存储空间不同。
	C++的基本数据类型有：整型（int)，字符型(char),单精度浮点型(float),双精度浮点型(double),空类型（void)。其中，signed,unsigned,short,long被称为修饰词。
	有符号整数在计算机内以二进制补码的形式存储的，存储单元的最高位用来表示数值的符号，“0”表示“正”，“1”表示“负”。
	无符号的整数只能是0和正数，其全部二进制位均表示数值本身。
	字符型本质上是整型，用于存放字符的ASCII码，长度为1个字节。
	布尔类型，也称为逻辑型，数据的取值只能是true(真)或false(假).
	空类型，常常作用于对函数返回值和函数参数的限定；定义无类型通用指针。
	每种数据类型均会占据固定长度的字节，这决定了它所能代表的数值范围。
	任何一种数据类型都有一个确定的最大值和最小值，若该类型数值的裱画超出了这个范围，即比最大值还大，比最小值还小，则会不正确，此种现象称为溢出。
	在C++中，当表达式中出现多种不同类型数据的混合运算时，往往需要进行数据类型转换。
	数据类型的转换分为隐含转换和强制转换。
	数据类型的隐含转换是指当运算符两边数据的类型不同时，系统自动会将其转换成同一数据类型后再进行运算。转换规则是将低类型数据转换为高类型数据,即
	char,short->int->unsigned->long->double
	float->double
	强制转换数据类型的一般形式为：(类型名) 变量/表达式 或者 类型名(变量/表达式)
	强制类型转换是暂时的，一次性的，只是将所需要转换的值从原变量中取出，转换类型后放在一个所需类型的中间变量中，而原来的变量类型不发生改变。
	强制类型转换是一种不安全的转换，会引起数据丢失。

2.3 常量和变量
=========
	常量是指在程序执行过程中值保持不变的量。

	变量是指在程序运行过程中可以改变的量。
	
	每个变量都必须在声明时明确定义其数据类型，并用标识符标识。

	常量分为字面常量和符号常量。

	符号常量是一个标识符，对应着一个和它类型一直的存储空间，该存储空间保存的数据即为该符号常量的值。

	C++中的常量分为整型常量、实型常量、字符常量、字符串常量和布尔型常量。

	整型常量表示通常意义上的整数，可以用十进制、八进制、十六进制表示。
		1)十进制整型常量：由正、负号和数字0-9组成，但数字部分不能以0开头。
		2)八进制整型常量：由正、负号和数字0-7组成，数字部分以0开头。
		3)十六进制整型常量：由正、负号和数字0-9，字母A-F组成，数字部分以0x或0X开头。

	实型常量是指通常意义上的实数，有两种表示形式：十进制小数形式和指数形式。
		1)十进制小数形式:由数字0-9和小数点组成。
		2)指数形式：也称科学计数法，其格式为小数E或e指数，表示“小数X10指数”。其中，小数可为正负，指数可为正负。
	
	字符常量分为普通字符常量和转义字符常量。

	普通字符常量是用单引号括起来的一个字符，且它只能包括一个字符，区分大小写。

	转义字符常量是由"\"开头的一个或多个字符的序列，用于表示一些无法显示的字符。

	

C++内存对齐
=========
	类中非静态成员变量的大小于编译器内存对齐：

	1.第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。
	
	2.在数据成员完成各自对齐后，类（结构或联合体）本身也要进行对齐，对齐按照#pragma pack指定的数值和结构或联合体最大数据成员长度中，比较小的那个进行。



C++的引用
=========
1.1 在声明引用时，必须同时对其进行初始化。引用的声明一般形式： 类型标识符 &引用名 = 被引用对象;

1.2 若不希望通过引用来改变原始变量的值，即称为常引用。常引用的声明一般形势：const 类型标识符 &引用名 = 被引用对象

1.3 在声明或定义函数时，将函数的形参执行为引用，则在调用该函数时会将实参直接传递给形参，而不是将实参拷贝传递给形参。

C++强制转换类型
=========
1.1 在C++中static_cast，const_cast，reinterpret_cast，dynmic_cast均是用于强制类型转换。


```	
	static_cast<new_type>      (expression)
	dynamic_cast<new_type>     (expression) 
	const_cast<new_type>       (expression) 
	reinterpret_cast<new_type> (expression)

```
1.2 static_cast用于数据类型的强制转换，强制将一种数据类型转换称为另一种数据类型。
		a.用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
		b.进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
		c.进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
		d.用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
		e.把空指针转换成目标类型的空指针。
		f.把任何类型的表达式转换成void类型。
		注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

1.3 const_cast用于强制去掉不能修改的常数特性。 

1.4 reinterpret_cast用于改变指针或引用的类型，将指针或引用转换为一个足够长度的整型，将整型转换为指针或引用类型。

1.5 dynamic_cast用于类的继承层次之间的强制类型转换。 


C++智能指针
=========
1.智能指针的原理:接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也将被释放掉了（除非将智能指针保存起来）。

2.C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头文件<memory>

3.shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。shared_ptr内部的引用计数是安全的，但是对象的读取需要加锁。

4.shared_ptr初始化:通過构造函数,std::make_shared<T>辅助函数和reset方法来初始化shared_ptr。其中，reset方法
	reset()包含两个操作。当智能指针中有值的时候，调用reset()会使引用计数减1.当调用reset（new xxx()重新赋值时，智能指针首先是生成新对象，然后将就对象的引用计数减1（当然，如果发现引用计数为0时，则析构旧对象），然后将新对象的指针交给智能指针保管。

5.获取原始指针，使用get方法。

6.智能指针可以指定删除器，当智能指针的引用计数为0时，自动调用指定的删除器来释放内存。std::shared_ptr可以指定删除器的一个原因是其默认删除器不支持数组对象。

7.使用shared_ptr需要注意的问题:a.不要用一个原始指针初始化多个shared_ptr，原因在于，会造成二次销毁.b.不要在函数实参中创建shared_ptr。因为C++的函数参数的计算顺序在不同的编译器下是不同的。正确的做法是先创建好，然后再传入.
	c.禁止通过shared_from_this()返回this指针，这样做可能也会造成二次析构.d.避免循环引用。智能指针最大的一个陷阱是循环引用，循环引用会导致内存泄漏。解决方法是相应的类型改为weak_ptr.

C++内联函数
=========

1.1内联函数能有效避免函数调用的开销，程序执行效率更高。缺点：若被声明为内联函数的函数体非常大，则编译器编译后程序的可执行代码会变得很大。


C++类与对象
=========
1.


C++多态性
=========
1.对象的静态类型：对象在声明时采用的类型。是在编译期确定的。

2.对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。

3.静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。

4.动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。

C++异常处理
=========
1.在C++中，一个函数能够检测出异常并且将异常返回，称该机制为抛出异常。当抛出异常后，函数调用者捕获到该异常，并对该异常进行处理，称之为异常捕获。

2.异常处理的一般声明形式：
	try{

	}catch(异常类型n){

	}


