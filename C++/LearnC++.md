C++
=========

1.C++ 完全支持面向对象的程序设计,封装,抽象,继承,多态.

C++的引用
=========
1.1 在声明引用时，必须同时对其进行初始化。引用的声明一般形式： 类型标识符 &引用名 = 被引用对象

1.2 若不希望通过引用来改变原始变量的值，即称为常引用。常引用的声明一般形似：const 类型标识符 &引用名 = 被引用对象

1.3 在声明或定义函数时，讲函数的形参执行为引用，则在调用该函数时会将实参直接传递给形参，而不是将实参拷贝传递给形参。

C++强制转换类型
=========
1.1 在C++中static_cast，const_cast，reinterpret_cast，dynmic_cast均是用于强制类型转换。
		static_cast<new_type>      (expression)
		dynamic_cast<new_type>     (expression) 
		const_cast<new_type>       (expression) 
		reinterpret_cast<new_type> (expression)

1.2 static_cast用于数据类型的强制转换，强制将一种数据类型转换称为另一种数据类型。
		a.用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
		b.进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
		c.进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
		d.用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
		e.把空指针转换成目标类型的空指针。
		f.把任何类型的表达式转换成void类型。
		注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

1.3 const_cast用于强制去掉不能修改的常数特性。 

1.4 reinterpret_cast用于改变指针或引用的类型，将指针或引用转换为一个足够长度的整型，将整型转换为指针或引用类型。

1.5 dynamic_cast用于类的继承层次之间的强制类型转换。 


C++智能指针
=========
1.智能指针的原理:接受一个申请好的内存地址，构造一个保存在栈上的智能指针对象，当程序退出栈的作用域范围后，由于栈上的变量自动被销毁，智能指针内部保存的内存也就被释放掉了（除非将智能指针保存起来）。

2.C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头文件<memory>

3.shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。shared_ptr内部的引用计数是安全的，但是对象的读取需要加锁。

4.shared_ptr初始化:通過构造函数,std::make_shared<T>辅助函数和reset方法来初始化shared_ptr。其中，reset方法
	reset()包含两个操作。当智能指针中有值的时候，调用reset()会使引用计数减1.当调用reset（new xxx()重新赋值时，智能指针首先是生成新对象，然后将就对象的引用计数减1（当然，如果发现引用计数为0时，则析构旧对象），然后将新对象的指针交给智能指针保管。

5.获取原始指针，使用get方法。

6.智能指针可以指定删除器，当智能指针的引用计数为0时，自动调用指定的删除器来释放内存。std::shared_ptr可以指定删除器的一个原因是其默认删除器不支持数组对象。

7.使用shared_ptr需要注意的问题:a.不要用一个原始指针初始化多个shared_ptr，原因在于，会造成二次销毁.b.不要在函数实参中创建shared_ptr。因为C++的函数参数的计算顺序在不同的编译器下是不同的。正确的做法是先创建好，然后再传入.
	c.禁止通过shared_from_this()返回this指针，这样做可能也会造成二次析构.d.避免循环引用。智能指针最大的一个陷阱是循环引用，循环引用会导致内存泄漏。解决方法是相应的类型改为weak_ptr.

C++内联函数
=========

1.1内联函数能有效避免函数调用的开销，程序执行效率更高。缺点：若被声明为内联函数的函数体非常大，则编译器编译后程序的可执行代码会变得很大。

C++多态性
=========
1.对象的静态类型：对象在声明时采用的类型。是在编译期确定的。

2.对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。

3.静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。

4.动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。
